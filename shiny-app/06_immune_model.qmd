---
title: "06_immune_model"
subtitle: "Place a subtitle here if needed"
author: "(Place your name/Unikey/SID)"
date: "`r format(Sys.time(), '%d %B, %Y')`"
format:
  html:
    code-tools: true
    code-fold: true
    fig_caption: yes
    number_sections: yes
    embed-resources: true
    theme: flatly
    css: 
      - https://use.fontawesome.com/releases/v5.0.6/css/all.css
    toc: true
    toc_depth: 4
    toc_float: true
execute:
  echo: true
  tidy: true
bibliography: references.bib 
---

# **1 Data Input and Pre-processing**

Select Top 50 Genes and Match to Expression Matrix

```{r}
library(dplyr)
library(tidyverse)

# Load data
pData <- readRDS("data/pData_final.rds")
eMat <- readRDS("data/eMat_with_symbols.rds")
top200 <- read.csv("data/top_200_genes_two_timepoints.csv")

# Select top genes
top_genes <- top200 %>% arrange(P.Value) %>% pull(X) %>% head(50)
genes_to_use <- intersect(top_genes, rownames(eMat))

# Preprocess pData
pData <- pData %>%
  mutate(
    sledai = as.numeric(sledai),
    visit = as.numeric(visit),
    cumulative_time = as.numeric(cumulative_time)
  ) %>%
  arrange(patient_id, visit) %>%
  group_by(patient_id) %>%
  mutate(
    sledai_next = lead(sledai),
    sledai_change = sledai_next - sledai,
    status = ifelse(!is.na(sledai_change) & sledai_change >= 3, 1, 0),
    time = visit,
    patient_str = sprintf("%03d", patient_id),
    visit_str = sprintf("%02d", visit),
    sample_id = paste0(group_type, "_", patient_str, "_V", visit_str)
  ) %>%
  ungroup()

# sample_id: SLE_018_V01
# patient_id: 18
```

```{r}
# Prepare expression matrix
eMat_subset <- eMat[genes_to_use, ]
eMat_transposed <- as.data.frame(t(eMat_subset))
eMat_transposed$sample_id <- rownames(eMat_transposed)

# Merge with pData
df_cox <- merge(eMat_transposed, pData, by = "sample_id") %>%
  filter(!is.na(status) & !is.na(time) & !is.na(sledai))
```

```{r}
# Clinical variables
clinical_vars <- c("neutrophil_count", "lymphocyte_count")

df_cox_filtered <- df_cox %>%
  select(any_of(c("sample_id", clinical_vars, genes_to_use, "sledai", "status", "time", "cumulative_time"))) %>%
  mutate(
    neutrophil_count = as.numeric(neutrophil_count),
    lymphocyte_count = as.numeric(lymphocyte_count)
  )

# Immune type classification
df_cox_filtered <- df_cox_filtered %>%
  mutate(
    immune_type = case_when(
      neutrophil_count > median(neutrophil_count, na.rm = TRUE) & lymphocyte_count <= median(lymphocyte_count, na.rm = TRUE) ~ "Innate-dominant",
      lymphocyte_count > median(lymphocyte_count, na.rm = TRUE) & neutrophil_count <= median(neutrophil_count, na.rm = TRUE) ~ "Adaptive-dominant",
      TRUE ~ "Mixed"
    )
  )

median(df_cox_filtered$neutrophil_count, na.rm = TRUE)
median(df_cox_filtered$lymphocyte_count, na.rm = TRUE)
```

## Immune System

We classified immune profiles into ‚Äúinnate-dominant,‚Äù ‚Äúadaptive-dominant,‚Äù and ‚Äúmixed‚Äù using cohort-based median splits of neutrophil and lymphocyte counts. This approach is consistent with prior work that used similar stratification to study immune activity in SLE patients [@qin2015nlr]

1.  üî¥ Innate-dominant

    **Definition:** Patients with high neutrophil count (above the cohort median) and low lymphocyte(b-cell/ t-cell) count (at or below the median).

    **Interpretation:** These patients show a stronger innate immune response, which is the body's fast, non-specific defense mechanism.

    **Potential association:** May be linked to acute inflammation or early immune activation.

2.  üîµ Adaptive-dominant

    **Definition:** Patients with high lymphocyte count and low neutrophil count.

    **Interpretation:** These patients show a stronger adaptive immune response, involving T and B cells that respond more specifically and are responsible for immune memory.

    **Potential association:** Could reflect chronic immune activation or response to past flares.

3.  ‚ö™ Mixed

    **Definition:** Patients who don‚Äôt meet the criteria for either of the above ‚Äî for example:

    Both neutrophil and lymphocyte counts are high.

    Both are low.

    Both are near the median.

    **Interpretation:** This group may represent a balanced or ambiguous immune state and serves as a heterogeneous reference group.

| Immune Type       | Description                  |
|-------------------|------------------------------|
| Innate-dominant   | Neutrophils ‚Üë, Lymphocytes ‚Üì |
| Adaptive-dominant | Lymphocytes ‚Üë, Neutrophils ‚Üì |
| Mixed             | All other cases              |

```{r}
#genes_to_use
#df_cox_filtered
```

> Out of 157 patients, 131 had at least two valid visits with available SLEDAI and time data, enabling slope computation for longitudinal modeling. Patients with only one valid visit were excluded, as slope estimation was not feasible for them.‚Äù

# 2 Cox Modeling Strategy

We used Cox proportional hazards models to predict flare risk using gene expression and/or clinical features. We evaluated:

-   Clinical score only (SLEDAI)

-   Gene expression only (top 50 genes)

-   Combined models

We compared two time variables: visit number and cumulative time since first visit. Models were also stratified by immune subtype.

# 3 **Cox Modeling Results**

## 3.1 SLEDAI, Gene Expression, and Combined Models

We compared three Cox models to assess the relative contributions of clinical vs gene expression predictors for flare risk:

-   The **SLEDAI-only model** yielded a C-index of **0.69**, indicating moderate ability to rank patients by risk using clinical disease activity alone.

-   The **gene-only model** performed slightly better (**0.74**), suggesting that transcriptomic data captures relevant flare signals.

-   The **combined model** achieved the highest concordance (**0.82**), showing that integrating clinical and molecular data yields the most predictive survival model.

```{r}
library(survival)
set.seed(123)
train_idx <- sample(nrow(df_cox_filtered), 0.8 * nrow(df_cox_filtered))
train_data <- df_cox_filtered[train_idx, ]
test_data <- df_cox_filtered[-train_idx, ]

# Fit and compare SLEDAI-only, gene-only, and combined models
# Model A: SLEDAI only
model_sledai <- coxph(Surv(time, status) ~ sledai, data = train_data)

# Model B: Gene expression only
cox_formula_genes <- as.formula(
  paste("Surv(time, status) ~", paste(sprintf("`%s`", genes_to_use), collapse = " + "))
)
model_genes <- coxph(cox_formula_genes, data = train_data)

# Model C: SLEDAI + gene expression
cox_formula_combined <- as.formula(
  paste("Surv(time, status) ~ sledai +", paste(sprintf("`%s`", genes_to_use), collapse = " + "))
)
model_combined <- coxph(cox_formula_combined, data = train_data)

# Extract C-index
concordance_sledai   <- summary(model_sledai)$concordance[1]
concordance_genes    <- summary(model_genes)$concordance[1]
concordance_combined <- summary(model_combined)$concordance[1]

# Combine into a data frame
comparison_df <- data.frame(
  Model = c("SLEDAI only", "Gene Expression only", "SLEDAI + Gene Expression"),
  Concordance = c(concordance_sledai, concordance_genes, concordance_combined)
)

library(DT)
datatable(
  comparison_df,
  caption = "Cox Model Comparison: Clinical vs Gene Expression vs Combined",
  options = list(dom = 't', autoWidth = TRUE),
  rownames = FALSE
)

```

## **3.2** Immune Subtype Stratification

We applied 5-fold **cross-validation** to evaluate gene-only Cox models within each immune subtype. The results show considerable variability in predictive performance:

```{r warning=FALSE}
# 5-fold CV per subtype: adaptive, innate, mixed
# Output mean C-index and SD

library(survival)
library(rsample)
library(dplyr)
library(purrr)

set.seed(123)
folds <- vfold_cv(df_cox_filtered, v = 5, strata = status)


cv_subtype_cindex <- function(split) {
  train_data <- analysis(split)
  test_data <- assessment(split)
  
  # Ensure valid numeric time variable
  train_data$time <- as.numeric(train_data$time)
  test_data$time <- as.numeric(test_data$time)
  
  # Gene-only formula
  cox_formula <- as.formula(
    paste("Surv(time, status) ~", paste(sprintf("`%s`", genes_to_use), collapse = " + "))
  )
  
  # Fit models per subtype on training
  fit_adaptive <- coxph(cox_formula, data = train_data %>% filter(immune_type == "Adaptive-dominant"))
  fit_innate   <- coxph(cox_formula, data = train_data %>% filter(immune_type == "Innate-dominant"))
  fit_mixed    <- coxph(cox_formula, data = train_data %>% filter(immune_type == "Mixed"))
  
  # Predict risk scores on test data (subtype-matched)
  test_data <- test_data %>%
    mutate(
      risk = case_when(
        immune_type == "Adaptive-dominant" ~ predict(fit_adaptive, newdata = ., type = "risk"),
        immune_type == "Innate-dominant"   ~ predict(fit_innate, newdata = ., type = "risk"),
        immune_type == "Mixed"             ~ predict(fit_mixed, newdata = ., type = "risk"),
        TRUE ~ NA_real_
      )
    )
  
  # Compute C-index per subtype
  c_adaptive <- tryCatch({
    survConcordance(Surv(time, status) ~ risk, data = test_data %>% filter(immune_type == "Adaptive-dominant"))$concordance
  }, error = function(e) NA)

  c_innate <- tryCatch({
    survConcordance(Surv(time, status) ~ risk, data = test_data %>% filter(immune_type == "Innate-dominant"))$concordance
  }, error = function(e) NA)

  c_mixed <- tryCatch({
    survConcordance(Surv(time, status) ~ risk, data = test_data %>% filter(immune_type == "Mixed"))$concordance
  }, error = function(e) NA)
  
  return(data.frame(
    adaptive = c_adaptive,
    innate = c_innate,
    mixed = c_mixed
  ))
}

cv_immune_results <- map_dfr(folds$splits, cv_subtype_cindex)


summary_immune <- data.frame(
  Immune_Type = c("Adaptive-dominant", "Innate-dominant", "Mixed"),
  Mean_Cindex = colMeans(cv_immune_results, na.rm = TRUE),
  SD = apply(cv_immune_results, 2, sd, na.rm = TRUE)
)

library(DT)
datatable(
  summary_immune,
  caption = "5-Fold Cross-Validated C-index by Immune Subtype (Gene-only Model)",
  options = list(dom = 't', autoWidth = TRUE),
  rownames = FALSE
)

```

| Immune Type | Mean C-index | SD | Interpretation |
|------------------|------------------|------------------|------------------|
| **Adaptive-dominant** | 0.543 | 0.134 | Slightly better than random |
| **Innate-dominant** | 0.605 | 0.184 | Moderately predictive |
| **Mixed** | 0.594 | 0.071 | Moderately predictive but with lower variability |

```{r}
library(broom)
cox_formula <- as.formula(
  paste("Surv(time, status) ~", paste(sprintf("`%s`", genes_to_use), collapse = " + "))
)

model_adaptive <- coxph(cox_formula, data = df_cox_filtered %>% filter(immune_type == "Adaptive-dominant"))
model_innate   <- coxph(cox_formula, data = df_cox_filtered %>% filter(immune_type == "Innate-dominant"))
model_mixed    <- coxph(cox_formula, data = df_cox_filtered %>% filter(immune_type == "Mixed"))

# Tidy results
results_adaptive <- tidy(model_adaptive) %>% mutate(immune_type = "Adaptive-dominant")
results_innate   <- tidy(model_innate) %>% mutate(immune_type = "Innate-dominant")
results_mixed    <- tidy(model_mixed) %>% mutate(immune_type = "Mixed")

# Combine and show
all_results <- bind_rows(results_adaptive, results_innate, results_mixed) %>%
  mutate(HR = exp(estimate)) %>%
  select(immune_type, term, estimate, HR, std.error, statistic, p.value)

all_results
```

# 4 **Time Scale Comparison**

## 4.1 Rationale and Time Variable Construction

-   **Peaks around 28‚Äì30, 60, and 90 days**: Suggests that visits were scheduled approximately monthly or quarterly for many patients.

-   **Long tail beyond 200 days**: Some patients had long gaps between visits (up to 2 years!).

-   Some visits occurred at **0 days**, likely meaning **same-day follow-up or repeated measures**.

```{r}
pData <- pData %>%
  mutate(days_since_last_visit = as.numeric(days_since_last_visit))

summary(pData$days_since_last_visit)
library(ggplot2)

ggplot(pData %>% filter(!is.na(days_since_last_visit)), 
       aes(x = days_since_last_visit)) +
  geom_histogram(binwidth = 10, fill = "steelblue", color = "white") +
  labs(
    title = "Distribution of Days Between Visits",
    x = "Days Since Last Visit",
    y = "Number of Visits"
  )
```

## 4.2 Single-Split Model Performance

In survival analysis, the choice of time scale is critical. The original dataset includes a `visit` variable (e.g., 1, 2, 3), which represents sequential clinical assessments. However, visits were **not equally spaced in time**, with intervals ranging from a few days to over 700 days.

To address this, we computed a new variable, `cumulative_time`, representing the **number of days since each patient‚Äôs first visit**. This provides a more accurate representation of follow-up duration in our time-to-event modeling.

```{r}
df_cox_filtered <- df_cox %>%
  select(any_of(c("sample_id", "cumulative_time", clinical_vars, genes_to_use, "sledai", "status", "time", "visit"))) %>%
  mutate(
    neutrophil_count = as.numeric(neutrophil_count),
    lymphocyte_count = as.numeric(lymphocyte_count)
  ) %>%
  mutate(
    immune_type = case_when(
      neutrophil_count > median(neutrophil_count, na.rm = TRUE) & lymphocyte_count <= median(lymphocyte_count, na.rm = TRUE) ~ "Innate-dominant",
      lymphocyte_count > median(lymphocyte_count, na.rm = TRUE) & neutrophil_count <= median(neutrophil_count, na.rm = TRUE) ~ "Adaptive-dominant",
      TRUE ~ "Mixed"
    ),
    scaled_time = ifelse(visit > 0, cumulative_time / visit, NA)
  )


names(train_data)  # Should include "cumulative_time"
summary(train_data$cumulative_time)  # Should not be all NA
```

```{r}
train_data$cumulative_time <- as.numeric(train_data$cumulative_time)
test_data$cumulative_time <- as.numeric(test_data$cumulative_time)

# Model 1: Using visit number (time)
cox_formula_visit <- as.formula(
  paste("Surv(time, status) ~", paste(sprintf("`%s`", genes_to_use), collapse = " + "))
)
model_visit <- coxph(cox_formula_visit, data = train_data)

# Model 2: Using cumulative time (in days)
cox_formula_cumulative <- as.formula(
  paste("Surv(cumulative_time, status) ~", paste(sprintf("`%s`", genes_to_use), collapse = " + "))
)
model_cumulative <- coxph(cox_formula_cumulative, data = train_data)

# Extract concordance index
concordance_visit <- summary(model_visit)$concordance[1]
concordance_cumulative <- summary(model_cumulative)$concordance[1]

# Create comparison table
comparison_time_models <- data.frame(
  Time_Variable = c("Visit Number (time)", "Cumulative Time (days)"),
  Concordance = c(concordance_visit, concordance_cumulative)
)

library(DT)
datatable(
  comparison_time_models,
  caption = "Comparison of Time Scales in Cox Model (Gene Expression Only)",
  options = list(dom = 't', autoWidth = TRUE),
  rownames = FALSE
)

```

## 4.3 Cross-Validation Comparison

```{r}
library(survival)
library(dplyr)
library(purrr)
library(rsample)  # for vfold_cv

set.seed(123)
folds <- vfold_cv(df_cox_filtered, v = 5, strata = status)  

# Define a function to compute C-index for a fold
get_cindex <- function(train_data, test_data, time_var) {
  # Build formula
  formula <- as.formula(
    paste0("Surv(", time_var, ", status) ~ ", paste(sprintf("`%s`", genes_to_use), collapse = " + "))
  )
  
  # Fit on training
  model <- coxph(formula, data = train_data)
  
  # Predict risk on testing
  test_data$risk_score <- predict(model, newdata = test_data, type = "risk")
  
  # Get concordance
  c_index <- tryCatch({
    survConcordance(Surv(test_data[[time_var]], test_data$status) ~ test_data$risk_score)$concordance
  }, error = function(e) NA)
  
  return(c_index)
}

# Loop over folds for both models
cv_results <- folds %>% 
  mutate(
    visit_cindex = map2_dbl(splits, id, ~{
      split_data <- analysis(.x)
      test_data <- assessment(.x)
      get_cindex(split_data, test_data, "time")
    }),
    cumulative_cindex = map2_dbl(splits, id, ~{
      split_data <- analysis(.x)
      test_data <- assessment(.x)
      
      # Ensure cumulative_time is numeric in both
      split_data$cumulative_time <- as.numeric(split_data$cumulative_time)
      test_data$cumulative_time <- as.numeric(test_data$cumulative_time)
      
      get_cindex(split_data, test_data, "cumulative_time")
    })
  )

summary_df <- data.frame(
  Model = c("Visit Number", "Cumulative Time"),
  Mean_Cindex = c(mean(cv_results$visit_cindex, na.rm = TRUE),
                  mean(cv_results$cumulative_cindex, na.rm = TRUE)),
  SD = c(sd(cv_results$visit_cindex, na.rm = TRUE),
         sd(cv_results$cumulative_cindex, na.rm = TRUE))
)

library(DT)
datatable(
  summary_df,
  caption = "5-Fold Cross-Validated C-index: Visit vs Cumulative Time",
  options = list(dom = 't', autoWidth = TRUE),
  rownames = FALSE
)

```

Initially, our gene-only Cox model achieved a C-index of 0.81 using a single train/test split, indicating strong predictive performance. However, 5-fold cross-validation revealed a mean C-index closer to 0.63, suggesting the original estimate was **optimistically biased**.

This discrepancy emphasizes the importance of using cross-validation to obtain more **robust and generalizable performance estimates**, especially in high-dimensional settings like gene expression analysis.

```{r}
set.seed(123)
folds <- vfold_cv(df_cox_filtered %>% filter(!is.na(scaled_time)), v = 10, strata = status)

# Define a function to compute C-index for a given time variable
get_cindex <- function(train_data, test_data, time_var) {
  # Build formula
  formula <- as.formula(
    paste0("Surv(", time_var, ", status) ~ ", paste(sprintf("`%s`", genes_to_use), collapse = " + "))
  )
  
  model <- coxph(formula, data = train_data)
  test_data$risk_score <- predict(model, newdata = test_data, type = "risk")

  tryCatch({
    survConcordance(Surv(test_data[[time_var]], test_data$status) ~ test_data$risk_score)$concordance
  }, error = function(e) NA)
}

# Compute C-index for all 3 time variables
cv_results <- folds %>% 
  mutate(
    visit_cindex = map2_dbl(splits, id, ~{
      split_data <- analysis(.x)
      test_data <- assessment(.x)
      get_cindex(split_data, test_data, "time")
    }),
    cumulative_cindex = map2_dbl(splits, id, ~{
      split_data <- analysis(.x)
      test_data <- assessment(.x)
      get_cindex(split_data, test_data, "cumulative_time")
    }),
    scaled_cindex = map2_dbl(splits, id, ~{
      split_data <- analysis(.x)
      test_data <- assessment(.x)
      get_cindex(split_data, test_data, "scaled_time")
    })
  )

# Create summary table
summary_df <- data.frame(
  Model = c("Visit Number", "Cumulative Time", "Scaled Time (cum_time / visit)"),
  Mean_Cindex = c(
    mean(cv_results$visit_cindex, na.rm = TRUE),
    mean(cv_results$cumulative_cindex, na.rm = TRUE),
    mean(cv_results$scaled_cindex, na.rm = TRUE)
  ),
  SD = c(
    sd(cv_results$visit_cindex, na.rm = TRUE),
    sd(cv_results$cumulative_cindex, na.rm = TRUE),
    sd(cv_results$scaled_cindex, na.rm = TRUE)
  )
)

datatable(
  summary_df,
  caption = "5-Fold Cross-Validated C-index: Visit vs Cumulative Time vs Scaled Time",
  options = list(dom = 't', autoWidth = TRUE),
  rownames = FALSE
)

```

# 5 Summary (2-4)

-   The combined gene expression model performed best overall
-   Time variable choice had modest effect: cumulative time slightly more interpretable
-   Cross-validation revealed lower C-index (\~0.63), highlighting importance of proper evaluation

# 6. Penalized Cox Modeling with LASSO

LASSO regularization was applied to a Cox model using only gene expression data in order to improve model generalizability and reduce overfitting from high-dimensional features. This approach automatically selects a sparse subset of predictive genes by shrinking others to zero.

We compared its performance to a standard Cox model with all top 50 genes using 5-fold cross-validation.

## 6.1 Gene-only LASSO Cox Model Performance

```{r warning=FALSE}
library(rsample)
library(purrr)
library(glmnet)
set.seed(123)
folds <- vfold_cv(df_cox_filtered, v = 5, strata = status)

# Function to compute C-index for LASSO model using genes only
get_lasso_cindex <- function(split) {
  train_data <- analysis(split) %>%
    filter(cumulative_time > 0) %>%
    mutate(cumulative_time = as.numeric(cumulative_time))

  test_data <- assessment(split) %>%
    filter(cumulative_time > 0) %>%
    mutate(cumulative_time = as.numeric(cumulative_time))

  X_train <- as.matrix(train_data[, genes_to_use])
  y_train <- Surv(train_data$cumulative_time, train_data$status)

  X_test <- as.matrix(test_data[, genes_to_use])
  y_test <- Surv(test_data$cumulative_time, test_data$status)

  model <- cv.glmnet(X_train, y_train, family = "cox", alpha = 1)

  risk_score <- predict(model, newx = X_test, s = "lambda.min", type = "link")
  c_index <- tryCatch({
    survConcordance(y_test ~ risk_score)$concordance
  }, error = function(e) NA)

  return(c_index)
}


lasso_gene_cindices <- map_dbl(folds$splits, get_lasso_cindex)

mean_cindex_lasso <- mean(lasso_gene_cindices, na.rm = TRUE)
sd_cindex_lasso <- sd(lasso_gene_cindices, na.rm = TRUE)

cindex_comparison <- data.frame(
  Model = c("Cox (Top 50 genes)", "LASSO Cox (Genes only)"),
  Mean_Cindex = c(
    mean(cv_results$cumulative_cindex, na.rm = TRUE),
    mean_cindex_lasso
  ),
  SD = c(
    sd(cv_results$cumulative_cindex, na.rm = TRUE),
    sd_cindex_lasso
  )
)

library(DT)
datatable(
  cindex_comparison,
  caption = "Cross-Validated C-index: Standard Cox vs LASSO Cox (Gene-only)",
  options = list(dom = 't', autoWidth = TRUE),
  rownames = FALSE
)


```

Although the standard Cox model using 50 genes yielded slightly higher mean C-index in cross-validation, we selected the **LASSO Cox (gene-only) model** as our final model due to its comparable predictive performance, lower variance, and practical advantages for deployment in a Shiny application. This regularized model automatically selected a sparse subset of informative genes, improving robustness and interpretability.

```{r warning=FALSE}
library(glmnet)

# Filter for valid cumulative time > 0
cox_lasso_data <- train_data %>% filter(cumulative_time > 0)

# Prepare input matrix and response (gene-only)
X <- as.matrix(cox_lasso_data[, genes_to_use])
y <- Surv(cox_lasso_data$cumulative_time, cox_lasso_data$status)

# Fit LASSO Cox model
cvfit <- cv.glmnet(X, y, family = "cox", alpha = 1)  # alpha = 1 for LASSO

# Plot cross-validated deviance
plot(cvfit)

# Extract non-zero coefficients at optimal lambda
selected_genes <- coef(cvfit, s = "lambda.min")
nonzero_genes <- selected_genes[selected_genes != 0]
nonzero_genes
```

What the two vertical lines mean:

| Line | Represents | Interpretation |
|---------------------|-------------------|---------------------------------|
| **Left vertical line** | `lambda.min` | The value of Œª that gives **the minimum cross-validated partial likelihood deviance** (i.e., best model fit). ‚úÖ |
| **Right vertical line** | `lambda.1se` | The **largest** Œª value within **1 standard error** of the minimum deviance. It gives a **simpler model** with **fewer variables**, but slightly worse fit. |

## 6.2 Final Model

cvfit \<- cv.glmnet(X, y, family = "cox", alpha = 1)

-   **Input data:** Gene expression only (top 50 genes)

-   **Time variable:** `cumulative_time` (in days since first visit)

-   **Status:** `status` (1 if SLEDAI increased by ‚â•3 at next visit, else 0)

-   **Outcome:** Time to flare

-   **Model selection:** Lambda chosen via 5-fold cross-validation (`lambda.min`)

-   **Performance:** Mean C-index from CV (‚âà0.63, comparable to full Cox model)

-   **Interpretability:** Sparse ‚Äî only genes with non-zero coefficients are selected

| Component | Description |
|------------------------------------|------------------------------------|
| **Predictors** | Expression of LASSO-selected genes (`genes_to_use`) |
| **Target** | Time to flare (via `Surv(time, status)`) |
| **Model type** | LASSO-penalized Cox proportional hazards model |
| **Output** | Risk score (log-hazard), used to stratify into High vs Low Risk |

```{r}
# List selected gene names
selected_gene_names <- rownames(selected_genes)[as.numeric(selected_genes) != 0]
selected_gene_names_df <- data.frame(Gene = selected_gene_names)

library(DT)
datatable(
  selected_gene_names_df,
  caption = "Genes Selected by LASSO Cox Model (lambda.min)",
  options = list(dom = 't', autoWidth = TRUE),
  rownames = FALSE
)

```

V1: The **partial log-hazard ratio** for that gene\
(i.e., how much the log-risk of flare increases or decreases per unit increase in expression)

```{r}
selected_genes <- coef(cvfit, s = "lambda.min")
nonzero_genes <- selected_genes[selected_genes != 0]
selected_gene_names <- rownames(selected_genes)[as.numeric(selected_genes) != 0]

gene_effects <- as.matrix(nonzero_genes)
sorted_genes <- gene_effects[order(abs(gene_effects), decreasing = TRUE), , drop = FALSE]
datatable(as.data.frame(sorted_genes), caption = "LASSO-Selected Genes Ordered by Effect Size")

```

Use the median split?

Concerns:

It always forces 50% of patients to be labeled ‚Äúhigh risk‚Äù ‚Äî even if **none of them** are truly at high clinical risk.

If all patients are truly low risk (e.g. very similar gene profiles), the ‚Äúhigh-risk‚Äù group might just be **marginally higher** but still clinically safe.

Conversely, in a high-risk cohort, the "low-risk" group may still be unsafe.

Without a known baseline, there's **no guarantee that the top half is dangerous**.

```{r}
# Predict risk scores on the full dataset using the LASSO model
X_all <- as.matrix(df_cox_filtered[, genes_to_use])
risk_scores <- predict(cvfit, newx = X_all, s = "lambda.min", type = "link")
# risk_scores: a risk score for each individual patient, derived from the LASSO Cox model using their gene expression profile.

# Add risk score and group label to the dataset
df_plot <- df_cox_filtered %>%
  mutate(
    risk_score = as.numeric(risk_scores),
    risk_group = ifelse(risk_score > median(risk_score, na.rm = TRUE), 
                        "High Risk", "Low Risk")
  )



```

```{r}
library(survival)
library(survminer)

# Build survival object
surv_obj <- Surv(time = df_plot$cumulative_time, event = df_plot$status)

# Fit Kaplan-Meier curves by risk group
fit <- survfit(surv_obj ~ risk_group, data = df_plot)

# Plot
ggsurvplot(
  fit,
  data = df_plot,
  pval = TRUE,
  risk.table = TRUE,
  legend.labs = c("High Risk", "Low Risk"),
  title = "Flare-Free Probability by LASSO Risk Group",
  xlab = "Days Since First Visit",
  ylab = "Flare-Free Probability",
  palette = c("firebrick", "steelblue")
)

```

This Kaplan‚ÄìMeier plot compares the **time to flare** (defined as a ‚â•3 point increase in SLEDAI score) between two patient groups stratified by **LASSO model‚Äìpredicted risk**:

üî¥ **High Risk Group (Red Line)**

-   These patients were assigned a higher predicted risk score by the LASSO Cox model.

-   Their survival curve drops more steeply, indicating a **higher and earlier occurrence of flares**.

-   By \~1000 days, the survival probability falls below **0.6**, showing that **more than 40%** of patients in this group had experienced a flare.

üîµ **Low Risk Group (Blue Line)**

-   These patients had lower predicted risk scores.

-   Their survival curve remains much flatter, indicating that **flares were less common and occurred later**.

-   By the end of follow-up (\~1500 days), **nearly 80%** of patients in this group remained flare-free.

üìä **Statistical Significance**

-   The **log-rank p-value \< 0.0001** indicates that the difference between the two survival curves is **highly statistically significant**.

-   This supports that the LASSO Cox model's risk scores **effectively stratify patients by flare risk**.

üß† **Clinical Insight**

-   The model-derived risk groups capture meaningful differences in disease progression.

-   **High-risk patients may benefit from more frequent monitoring or preventive interventions**, while low-risk patients might follow less intensive protocols.

    ## 6.2 Survival Curves by Immune Subtype √ó Risk Group

    ```{r}
    df_plot <- df_plot %>%
      mutate(immune_risk_group = paste(immune_type, "-", risk_group))

    group_palette <- c(
      "Innate-dominant - High Risk"   = "#D73027",
      "Innate-dominant - Low Risk"    = "#FC8D59",
      "Adaptive-dominant - High Risk" = "#4575B4",
      "Adaptive-dominant - Low Risk"  = "#91BFDB",
      "Mixed - High Risk"             = "#984EA3",
      "Mixed - Low Risk"              = "#B3B3B3"
    )

    surv_obj <- Surv(time = df_plot$cumulative_time, event = df_plot$status)
    fit <- survfit(surv_obj ~ immune_risk_group, data = df_plot)

    # Extract survival curve data
    curve_df <- survminer::surv_summary(fit, data = df_plot)

    # Clean strata names
    curve_df$strata <- gsub("immune_risk_group=", "", curve_df$strata)

    p_clean <- ggplot(curve_df, aes(x = time, y = surv, color = strata, group = strata)) +
      geom_step(size = 1.2, aes(text = paste0(
        "Group: ", strata, "<br>",
        "Time: ", time, " days<br>",
        "Flare-Free Prob: ", round(surv, 3)
      ))) +
      scale_color_manual(values = group_palette) +
      labs(
        title = "Flare-Free Probability by Immune Subtype and Risk",
        x = "Days Since First Visit",
        y = "Flare-Free Probability",
        color = "Subtype + Risk Group"
      ) +
      theme_minimal(base_size = 15)

    ggplotly(p_clean, tooltip = "text")
    #saveRDS(df_cox_filtered, "data/df_cox_filtered.rds")
    ```

    üìä Interpretation

#### Adaptive-dominant ‚Äì Low Risk

-   Survival curve remains near 1 throughout follow-up.

-   Patients with strong adaptive immune profiles and low predicted risk rarely flared.

#### Mixed ‚Äì Low Risk

-   Also exhibited excellent flare-free survival.

-   Indicates that the LASSO model effectively identifies stable patients, even in a heterogeneous group.

#### Innate-dominant ‚Äì Low Risk

-   Flat survival curve, suggesting that low-risk predictions hold true even in a classically higher-risk subtype.

#### Mixed ‚Äì High Risk

-   Shows a more rapid decline in survival probability.

-   Suggests increased vulnerability to flares, but with moderate variability.

#### Adaptive-dominant ‚Äì High Risk

-   Moderate decline in survival, suggesting higher flare risk than low-risk counterparts.

-   Flares appear delayed or less frequent compared to Innate-dominant high-risk patients.

#### Innate-dominant ‚Äì High Risk

-   This group had the **steepest survival drop**, with many patients experiencing early flares.

-   Suggests a compounding effect of innate-dominant immune profile and high transcriptomic risk.

#### üß† Clinical Insight

-   The **LASSO-predicted risk score remains informative within each immune subtype**.

-   Patients in the **Innate-dominant ‚Äì High Risk** group may require **intensive monitoring and early intervention**.

-   Low-risk patients across all immune subtypes showed excellent outcomes, highlighting the potential of this model to **reduce overtreatment**.

#### üìå Statistical Evidence

-   **Log-rank test p \< 0.0001**, confirming the survival differences among groups are **statistically significant**.

# References
